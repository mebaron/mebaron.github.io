---
title: go正则处理
type: tags
date: 2023-12-28 17:34:51
tags:
- go
- 正则表达式
categories:
- 学习笔记
---

## go正则处理

### 1.正则表达式语法

go的regexp正则表达式库采用RE2语法，细节可参考[文档](https://github.com/google/re2/wiki/Syntax)，常见的用法如下：

|  字符  |                             描述                             |
| :----: | :----------------------------------------------------------: |
| [ABC]  |                  匹配 [...] 中的所有字符。                   |
| [^ABC] |              匹配除了 [...] 中字符的所有字符。               |
| [A-Z]  | [A-Z] 表示一个区间，匹配所有大写字母，[a-z] 表示所有小写字母。 |
|   .    | 匹配除换行符（\n、\r）之外的任何单个字符。要匹配 . ，请使用 \\. 。 |
| [\s\S] | 匹配所有。\s 是匹配所有空白符，包括换行，\S 非空白符，不包括换行。 |
|   \w   |        匹配字母、数字、下划线。等价于 [A-Za-z0-9_]。         |
|   \d   |       匹配任意一个阿拉伯数字（0 到 9）。等价于 [0-9]。       |
|   ^    | 匹配输入字符串的开始位置，除非在方括号表达式中使用，当该符号在方括号表达式中使用时，表示不接受该方括号表达式中的字符集合。要匹配 ^ 字符本身，请使用 \^。 |
|   $    | 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \\$。 |
|  ( )   | 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和\ \)。 |
|   *    |  匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 \\*。   |
|   +    |  匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 \\+。   |
|   ?    | 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 \?。 |
|  {n}   |           n 是一个非负整数。匹配确定的 **n** 次。            |
|  {n,}  |               n 是一个非负整数。至少匹配n 次。               |
| {n,m}  | m 和 n 均为非负整数，其中 n <= m。最少匹配 n 次且最多匹配 m 次。 |
|   \|   |        指明两项之间的一个选择。要匹配 \|，请使用 \|。        |

### 2.正则表达式处理函数

Regexp类型提供了多达16个方法，用于匹配正则表达式并获取匹配的结果。它们的名字满足如下正则表达式：

```
Find(All)?(String)?(Submatch)?(Index)?
```

如果**'All'**出现了，该方法会返回输入中所有互不重叠的匹配结果。如果一个匹配结果的前后（没有间隔字符）存在长度为0的成功匹配，该空匹配会被忽略。包含All的方法会要求一个额外的整数参数n，如果n>=0，方法会返回最多前n个匹配结果。

如果**'String'**出现了，匹配对象为字符串，否则应该是[]byte类型，返回值和匹配对象的类型是对应的。

如果**'Submatch'**出现了，返回值是表示正则表达式中成功的组匹配（子匹配/次级匹配）的切片。组匹配是正则表达式内部的括号包围的次级表达式（也被称为“捕获分组”），从左到右按左括号的顺序编号。索引0的组匹配为完整表达式的匹配结果，1为第一个分组的匹配结果，依次类推。

如果**'Index'**出现了，匹配/分组匹配会用输入流的字节索引对表示result[2*n:2*n+1]表示第n个分组匹配的的匹配结果。如果没有'Index'，匹配结果表示为匹配到的文本。如果索引为负数，表示分组匹配没有匹配到输入流中的文本。

#### 2.1.通过正则判断是否匹配

```go
package main

import (
	"fmt"
	"regexp"
)

var (
	tel  string = "13565248564"
	data []byte = []byte{'a', 'b', 'c'}
)

func main() {
    // 判断字符串是否匹配
	matched, _ := regexp.MatchString("^[0-9]{11}$", tel)
	fmt.Printf("matched: %v\n", matched)

    // 判断[]byte类型是否匹配
	matched, _ = regexp.Match("^[a-z]+$", data)
	fmt.Printf("matched: %v\n", matched)
}
```

#### 2.2.通过正则获取内容

```go
package main

import (
	"fmt"
	"regexp"
)

var (
	tel string = "123abc456bvf789bjs"
)

func main() {
	// 校验正则表达式
	reg, _ := regexp.Compile("[0-9]{3}")

	// 匹配字符串内容
	res := reg.FindAllString(tel, -1)
	for _, v := range res {
		fmt.Printf("v: %v\n", v)
	}

	// 组匹配
	reg, _ = regexp.Compile("([0-9]{3})([a-z]{1})")
	res = reg.FindStringSubmatch(tel)
	for _, v := range res {
		fmt.Printf("v: %v\n", v)
	}

	// 获取匹配元素在原字符串的下标信息
	sum := reg.FindStringIndex(tel)
	fmt.Printf("tel[sum[0]:sum[1]]: %v\n", tel[sum[0]:sum[1]])
}
```

